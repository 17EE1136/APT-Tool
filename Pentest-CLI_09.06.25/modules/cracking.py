import subprocess
import os
import concurrent.futures

def create_target_folder(target):
    folder = f"results/{target}/cracking"
    os.makedirs(folder, exist_ok=True)
    return folder

def get_wordlist():
    wl = input("Enter path to wordlist (Enter for /usr/share/wordlists/rockyou.txt): ")
    if not wl:
        wl = "/usr/share/wordlists/rockyou.txt"
    if not os.path.isfile(wl):
        print("[!] Invalid wordlist, using default.")
        wl = "/usr/share/wordlists/rockyou.txt"
    return wl

# --- per-tool functions ---

#def run_john_the_ripper(target, wordlist):
#    outfile = f"results/{target}/cracking/john_the_ripper.txt"
#    cmd = f"john {target} --wordlist={wordlist} --show > {outfile}"
#    #cmd = f"john {target} --wordlist={wordlist} -o  {outfile}"
#    subprocess.run(cmd, shell=True)
    
def run_john_the_ripper(target, wordlist):
    outfile = f"results/{target}/cracking/john_the_ripper.txt"
    # run John with your wordlist, capture all output in the log
    cmd = f"john --wordlist={wordlist} {target} 2>&1 | tee {outfile}"
    subprocess.run(cmd, shell=True)


def run_hashcat(target, wordlist):
    outfile = f"results/{target}/cracking/hashcat.txt"
    #cmd = f"hashcat -m 0 -a 0 {target} {wordlist} -o {outfile}"
    #cmd = f"hashcat -m 0 -a 0 {target} {wordlist} --outfile {outfile}"
# don't call --show here: we just crack, log everything instead
    cmd = f"hashcat -m 0 -a 0 {target} {wordlist} -o {outfile} 2>&1 | tee {outfile}"
    subprocess.run(cmd, shell=True)

def run_medusa(target, wordlist):
    outfile = f"results/{target}/cracking/medusa.txt"
#   cmd = f"medusa -h {target} -u admin -P {wordlist} -M http -o {outfile}"
#----------------------------------------------------------------------------------------------
    # medusa uses -O for logfile, not -o
    cmd = f"medusa -h {target} -u admin -P {wordlist} -M http -O {outfile}"
#-----------------------------------------------------------------------------------------------
    subprocess.run(cmd, shell=True)

def run_hydra(target, wordlist):  # Hydra example: SSH only
    outfile = f"results/{target}/cracking/hydra.txt"
    #cmd = f"hydra -l admin -P {wordlist} {target} http-get / -o {outfile}"
    #cmd = f"hydra -l admin -P {wordlist} {target} ssh"
    cmd = f"hydra -l admin -P {wordlist} {target} ssh -o {outfile}"
    subprocess.run(cmd, shell=True)

# tool→func mapping (wordlist argument optional for non‐wordlist tools)
tools_mapping = {
   # "John the Ripper": lambda t, wl=None: run_john_the_ripper(t, wl),
   # "Hashcat":         lambda t, wl=None: run_hashcat(t, wl),
    "John the Ripper": run_john_the_ripper,
    "Hashcat":         run_hashcat,
    "Medusa":          run_medusa,
    "Hydra":           run_hydra,
}

def run_cracking_tools(target, tools):
    """
    Run selected cracking tools *in parallel* against one target.
    """
    create_target_folder(target)
    wordlist = get_wordlist()

  #  with concurrent.futures.ThreadPoolExecutor() as executor:
 #       futures = {
  #          executor.submit(
 #               tools_mapping[tool], target, wordlist
 #           ): tool
  #          for tool in tools if tool in tools_mapping
  #      }
#------------------------------------------------------------------------------------------------     
# changed --If you’d rather have the cracker script detect “file vs. host” and only run the proper tools, you can edit cracking.py:
    is_file = os.path.isfile(target)
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {}
        for tool in tools:
            if tool in ["John the Ripper", "Hashcat"] and is_file:
                futures[executor.submit(tools_mapping[tool], target, wordlist)] = tool
            elif tool in ["Medusa", "Hydra"] and not is_file:
                futures[executor.submit(tools_mapping[tool], target, wordlist)] = tool
            else:
                print(f"[!] Skipping {tool} for {target} (incompatible).")
 #------------------------------------------------------------------------------------------------       
        for future in concurrent.futures.as_completed(futures):
            tool = futures[future]
            try:
                future.result()
                print(f"[+] {tool} completed successfully on {target}")
            except Exception as e:
                print(f"[!] {tool} failed on {target}: {e}")

    print(f"[+] Cracking finished for {target}\n")


def run_cracking_batch(targets, tools):
    """
    Fire off one thread per target, each running run_cracking_tools().
    """
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = {
            executor.submit(run_cracking_tools, t.strip(), tools): t.strip()
            for t in targets if t.strip()
        }
        for future in concurrent.futures.as_completed(futures):
            tgt = futures[future]
            try:
                future.result()
            except Exception as e:
                print(f"[!] Error cracking {tgt}: {e}")
    print("[+] All cracking batches complete.\n")
